/**
 * INSTRUCCIONES: Agrega este c√≥digo a backend/server.ts
 * 
 * UBICACI√ìN: Despu√©s de la secci√≥n "RUTAS DE PRODUCTOS" y ANTES de "RUTAS PROTEGIDAS"
 * 
 * Busca esta l√≠nea en server.ts:
 *   });
 * });
 * 
 * // ==================== RUTAS PROTEGIDAS (EJEMPLO) ====================
 * 
 * Y PEGA ESTO JUSTO ANTES:
 */

// ==================== RUTAS DE √ìRDENES ====================

/**
 * POST /api/orders
 * Crea una nueva orden con datos completos del cliente
 * ACCESO: P√∫blico (no requiere autenticaci√≥n para permitir checkout como invitado)
 */
app.post('/api/orders', async (req: Request, res: Response) => {
    try {
        const { customerName, customerEmail, phone, address, paymentMethod, total, items } = req.body;

        // Validaciones
        if (!customerName || !customerEmail || !phone || !address || !paymentMethod) {
            return res.status(400).json({ 
                error: 'Faltan datos obligatorios del cliente',
                required: ['customerName', 'customerEmail', 'phone', 'address', 'paymentMethod']
            });
        }

        if (!total || total <= 0) {
            return res.status(400).json({ error: 'El total de la orden debe ser mayor a 0' });
        }

        if (!items || !Array.isArray(items) || items.length === 0) {
            return res.status(400).json({ error: 'La orden debe tener al menos un producto' });
        }

        // Validar email
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(customerEmail)) {
            return res.status(400).json({ error: 'Email inv√°lido' });
        }

        // Iniciar transacci√≥n
        const order = await prisma.$transaction(async (tx) => {
            // 1. Crear orden
            const newOrder = await tx.order.create({
                data: {
                    customerName,
                    customerEmail,
                    phone,
                    address,
                    paymentMethod,
                    total,
                    status: 'PENDING'
                }
            });

            // 2. Crear items y actualizar stock
            for (const item of items) {
                // Validar que el producto existe y tiene stock suficiente
                const product = await tx.product.findUnique({
                    where: { id: item.productId }
                });

                if (!product) {
                    throw new Error(`Producto con ID ${item.productId} no encontrado`);
                }

                if (product.stock < item.quantity) {
                    throw new Error(`Stock insuficiente para ${product.title}. Disponible: ${product.stock}, Solicitado: ${item.quantity}`);
                }

                // Crear item de la orden
                await tx.orderItem.create({
                    data: {
                        orderId: newOrder.id,
                        productId: item.productId,
                        quantity: item.quantity,
                        price: item.price
                    }
                });

                // Actualizar stock y ventas
                await tx.product.update({
                    where: { id: item.productId },
                    data: {
                        stock: {
                            decrement: item.quantity
                        },
                        sales: {
                            increment: item.quantity
                        },
                        dailySales: {
                            increment: item.quantity
                        }
                    }
                });
            }

            // 3. Actualizar estado de la orden a completada
            return await tx.order.update({
                where: { id: newOrder.id },
                data: { status: 'COMPLETED' },
                include: {
                    items: {
                        include: {
                            product: {
                                select: {
                                    id: true,
                                    title: true,
                                    image: true
                                }
                            }
                        }
                    }
                }
            });
        });

        // Log de seguridad
        console.log(`[√ìRDEN] Nueva orden creada: #${order.id}`);
        console.log(`  Cliente: ${customerName} (${customerEmail})`);
        console.log(`  Total: $${total}`);
        console.log(`  Productos: ${items.length}`);
        console.log(`  M√©todo de pago: ${paymentMethod}`);

        res.status(201).json({
            success: true,
            message: 'Orden creada exitosamente',
            order: {
                id: order.id,
                customerName: order.customerName,
                customerEmail: order.customerEmail,
                phone: order.phone,
                address: order.address,
                paymentMethod: order.paymentMethod,
                total: order.total,
                status: order.status,
                createdAt: order.createdAt,
                items: order.items.map(item => ({
                    id: item.id,
                    productId: item.productId,
                    productTitle: item.product.title,
                    productImage: item.product.image,
                    quantity: item.quantity,
                    price: item.price
                }))
            }
        });

    } catch (error: any) {
        console.error('[ERROR] Create order failed:', error);
        
        // Errores espec√≠ficos
        if (error.message.includes('no encontrado') || error.message.includes('insuficiente')) {
            return res.status(400).json({ error: error.message });
        }
        
        res.status(500).json({ error: 'Error al crear la orden' });
    }
});

/**
 * GET /api/orders
 * Obtiene todas las √≥rdenes con sus items
 * ACCESO: Requiere autenticaci√≥n (solo admin puede ver todas las √≥rdenes)
 */
app.get('/api/orders', authenticateToken, async (req: AuthRequest, res: Response) => {
    try {
        const orders = await prisma.order.findMany({
            include: {
                items: {
                    include: {
                        product: {
                            select: {
                                id: true,
                                title: true,
                                image: true,
                                price: true,
                                category: true
                            }
                        }
                    }
                }
            },
            orderBy: {
                createdAt: 'desc'
            }
        });

        // Formatear response
        const formattedOrders = orders.map(order => ({
            id: order.id,
            customerName: order.customerName,
            customerEmail: order.customerEmail,
            phone: order.phone,
            address: order.address,
            paymentMethod: order.paymentMethod,
            total: order.total,
            status: order.status,
            createdAt: order.createdAt,
            items: order.items.map(item => ({
                id: item.id,
                orderId: item.orderId,
                productId: item.productId,
                productTitle: item.product.title,
                productImage: item.product.image,
                quantity: item.quantity,
                price: item.price
            }))
        }));

        res.json({ 
            success: true, 
            orders: formattedOrders,
            total: formattedOrders.length
        });

    } catch (error) {
        console.error('[ERROR] Get orders failed:', error);
        res.status(500).json({ error: 'Error al obtener √≥rdenes' });
    }
});

/**
 * GET /api/orders/:id
 * Obtiene una orden espec√≠fica por ID
 * ACCESO: Requiere autenticaci√≥n
 */
app.get('/api/orders/:id', authenticateToken, async (req: AuthRequest, res: Response) => {
    try {
        const orderId = parseInt(req.params.id, 10);

        if (isNaN(orderId)) {
            return res.status(400).json({ error: 'ID de orden inv√°lido' });
        }

        const order = await prisma.order.findUnique({
            where: { id: orderId },
            include: {
                items: {
                    include: {
                        product: {
                            select: {
                                id: true,
                                title: true,
                                image: true,
                                price: true,
                                category: true
                            }
                        }
                    }
                }
            }
        });

        if (!order) {
            return res.status(404).json({ error: 'Orden no encontrada' });
        }

        res.json({
            success: true,
            order: {
                id: order.id,
                customerName: order.customerName,
                customerEmail: order.customerEmail,
                phone: order.phone,
                address: order.address,
                paymentMethod: order.paymentMethod,
                total: order.total,
                status: order.status,
                createdAt: order.createdAt,
                items: order.items.map(item => ({
                    id: item.id,
                    productId: item.productId,
                    productTitle: item.product.title,
                    productImage: item.product.image,
                    quantity: item.quantity,
                    price: item.price
                }))
            }
        });

    } catch (error) {
        console.error('[ERROR] Get order failed:', error);
        res.status(500).json({ error: 'Error al obtener orden' });
    }
});

/**
 * PATCH /api/orders/:id/status
 * Actualiza el estado de una orden
 * ACCESO: Solo admin
 */
app.patch('/api/orders/:id/status', authenticateToken, requireAdmin, async (req: AuthRequest, res: Response) => {
    try {
        const orderId = parseInt(req.params.id, 10);
        const { status } = req.body;

        // Validar estados permitidos
        const validStatuses = ['PENDING', 'PROCESSING', 'COMPLETED', 'CANCELLED'];
        if (!validStatuses.includes(status)) {
            return res.status(400).json({ 
                error: 'Estado inv√°lido',
                validStatuses
            });
        }

        const order = await prisma.order.update({
            where: { id: orderId },
            data: { status }
        });

        console.log(`[√ìRDEN] Estado actualizado: Orden #${orderId} -> ${status} por ${req.user?.username}`);

        res.json({
            success: true,
            message: 'Estado de orden actualizado',
            order
        });

    } catch (error: any) {
        console.error('[ERROR] Update order status failed:', error);
        
        if (error.code === 'P2025') {
            return res.status(404).json({ error: 'Orden no encontrada' });
        }
        
        res.status(500).json({ error: 'Error al actualizar estado de orden' });
    }
});

/**
 * DELETE /api/orders/:id
 * Elimina una orden (solo admin)
 * NOTA: Esto NO restaura el stock autom√°ticamente
 * ACCESO: Solo admin
 */
app.delete('/api/orders/:id', authenticateToken, requireAdmin, async (req: AuthRequest, res: Response) => {
    try {
        const orderId = parseInt(req.params.id, 10);

        // Verificar que la orden existe
        const order = await prisma.order.findUnique({
            where: { id: orderId },
            include: { items: true }
        });

        if (!order) {
            return res.status(404).json({ error: 'Orden no encontrada' });
        }

        // Eliminar orden (cascade eliminar√° los items autom√°ticamente)
        await prisma.order.delete({
            where: { id: orderId }
        });

        console.log(`[√ìRDEN] Orden eliminada: #${orderId} por ${req.user?.username}`);
        console.log(`  ‚ö†Ô∏è  NOTA: Stock NO restaurado autom√°ticamente`);

        res.json({
            success: true,
            message: 'Orden eliminada exitosamente',
            warning: 'El stock NO fue restaurado autom√°ticamente. Ajusta manualmente si es necesario.'
        });

    } catch (error) {
        console.error('[ERROR] Delete order failed:', error);
        res.status(500).json({ error: 'Error al eliminar orden' });
    }
});

// ==================== FIN DE RUTAS DE √ìRDENES ====================

/**
 * FINALMENTE, actualiza el mensaje de inicio del servidor:
 * 
 * Busca estas l√≠neas al final del archivo:
 *     console.log(`üì¶ Products API enabled`);
 * 
 * Y agrega despu√©s:
 *     console.log(`üõçÔ∏è Orders API enabled (POST, GET, PATCH, DELETE)`);
 */
