generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ⚠️ NOTA: SQLite no soporta enums, usamos String con validación en backend
// Valores válidos: "ADMIN", "USER", "CLIENT"

model User {
  id           Int       @id @default(autoincrement())
  username     String    @unique
  email        String    @unique
  passwordHash String
  
  // ✅ ACTUALIZADO: role como String (SQLite no soporta enum)
  // Valores: "ADMIN" | "USER" | "CLIENT"
  role         String    @default("CLIENT")
  
  // ✅ NUEVO: Sistema de puntos de fidelización
  loyaltyPoints Int      @default(0) // 10 puntos por cada dólar
  
  createdAt    DateTime  @default(now())
  lastLogin    DateTime?
  
  refreshTokens    RefreshToken[]
  pointsHistory    LoyaltyPointsHistory[]
  orders           ClientOrder[]
  
  @@index([role])
  @@index([loyaltyPoints])
}

// ✅ NUEVO: Historial de puntos de fidelización
model LoyaltyPointsHistory {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  points      Int      // Puntos ganados/usados (positivo = ganado, negativo = usado)
  orderId     Int?     // Relación con la orden que generó los puntos
  description String   // "Compra de $50.00", "Descuento aplicado", etc.
  
  createdAt   DateTime @default(now())
  
  @@index([userId, createdAt])
}

// ✅ NUEVO: Órdenes de clientes (separado de Order para trazabilidad)
model ClientOrder {
  id              Int      @id @default(autoincrement())
  userId          Int?
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  total           Float
  pointsEarned    Int      @default(0)  // Puntos ganados en esta compra
  pointsUsed      Int      @default(0)  // Puntos usados como descuento
  discount        Float    @default(0)  // Descuento aplicado en dólares
  
  status          String   @default("completed")
  createdAt       DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([createdAt])
}

model RefreshToken {
  id        Int      @id @default(autoincrement())
  token     String   @unique
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model Product {
  id           Int      @id @default(autoincrement())
  title        String
  description  String?
  price        Float
  stock        Int      @default(0)
  initialStock Int?     // Stock inicial de referencia
  unit         String
  image        String?
  rating       Float    @default(0)
  category     String?
  sales        Int      @default(0) // Total de unidades vendidas (NUNCA se resetea - para ingresos totales)
  dailySales   Int      @default(0) // Ventas diarias (se resetea al ajustar stock - para reportes diarios)
  
  // ✅ SISTEMA DE SLOTS (Hardware ESP32/Arduino)
  slot         Int?     // Número de slot asignado (1, 2, 3, ...)
  slotDistance Int?     // Distancia en centímetros que debe moverse el motor
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  batches          Batch[]
  orderItems       OrderItem[]
  stockAdjustments StockAdjustment[]

  // ✅ OPTIMIZACIÓN: Índices para búsquedas comunes
  @@index([title])    // Para búsquedas por nombre
  @@index([category]) // Para filtrado por categoría
  @@index([stock])    // Para queries de stock bajo
  @@index([sales])    // Para reportes de productos más vendidos
  @@index([slot])     // Para búsqueda rápida de productos por slot
}

model Batch {
  id             Int      @id @default(autoincrement())
  productId      Int
  product        Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  batchCode      String   // Formato: ArrPreBl-1-15122025 (PrimerProd-SecuenciaLote-Fecha)
  quantity       Int
  expiryDate     DateTime
  createdAt      DateTime @default(now())

  // ✅ OPTIMIZACIÓN: Índices para mejorar performance de queries FIFO
  @@index([productId, expiryDate]) // Para consumeBatchesFIFO (query más crítica)
  @@index([expiryDate])            // Para getExpiringBatches
  @@index([batchCode])             // Para búsquedas por código de lote
}

// ✅ ACTUALIZADO: Order con campos completos de cliente
model Order {
  id             Int         @id @default(autoincrement())
  
  // Datos del cliente
  customerName   String
  customerEmail  String
  phone          String
  address        String
  paymentMethod  String
  
  // Datos de la orden
  total          Float
  status         String      @default("PENDING")
  
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt
  
  items          OrderItem[]

  // ✅ OPTIMIZACIÓN: Índices para historial de órdenes
  @@index([createdAt]) // Para ordenar por fecha
  @@index([status])    // Para filtrar por estado
  @@index([customerEmail]) // Para buscar por cliente
}

model OrderItem {
  id        Int     @id @default(autoincrement())
  orderId   Int
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  productId Int
  product   Product @relation(fields: [productId], references: [id])
  quantity  Int
  price     Float
  
  @@index([orderId])
  @@index([productId])
}

model StockAdjustment {
  id             Int      @id @default(autoincrement())
  productId      Int
  product        Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  adjustmentType String   // manual, restock, correction, damage, count, batch (cuando se crea un lote)
  quantityBefore Int
  quantityAfter  Int
  difference     Int
  note           String?  // Para ajustes tipo 'batch', incluye el código del lote
  userId         String?
  timestamp      DateTime @default(now())

  // ✅ OPTIMIZACIÓN: Índices para reportes
  @@index([productId, timestamp]) // Para historial por producto
  @@index([timestamp])            // Para reportes por fecha
  @@index([adjustmentType])       // Para filtrar por tipo
}
